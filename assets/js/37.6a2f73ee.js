(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{402:function(v,t,_){"use strict";_.r(t);var e=_(42),r=Object(e.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"盒模型的应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#盒模型的应用"}},[v._v("#")]),v._v(" 盒模型的应用")]),v._v(" "),_("p",[v._v("默认情况下，盒子都是标准盒模型（也就是content-box）,width和 height设置的是content区域的宽度和高度")]),v._v(" "),_("p",[v._v("通常这种情况下如果再设置padding，border后，会比预期的width，height显示效果还要大一点，通常解决办法有：")]),v._v(" "),_("ol",[_("li",[v._v("精确计算，比如这个盒子整体显示是200*200，padding区域要50px，那么width和height就只能设置为150px。")]),v._v(" "),_("li",[v._v("css3：box-sizing(盒尺寸)，这个属性会影响width和height设置的是那种盒模型的宽和高，默认值是content-box，那么width和height设置的就是内容的宽和高，第二个属性值是："),_("code",[v._v("border-box")]),v._v(",指的是width和height设置的是content+padding+border的宽度之和，然后里面各区域的内容就自动计算。")])]),v._v(" "),_("h3",{attrs:{id:"改变背景的覆盖范围"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#改变背景的覆盖范围"}},[v._v("#")]),v._v(" 改变背景的覆盖范围")]),v._v(" "),_("p",[v._v("默认情况下，背景覆盖到边框盒。但是可以通过"),_("code",[v._v("background-clip")]),v._v("来修改")]),v._v(" "),_("p",[_("code",[v._v("background-clip")]),v._v("常用的三个值：")]),v._v(" "),_("ol",[_("li",[v._v("border-box:表示背景向外填充到border")]),v._v(" "),_("li",[v._v("padding:表示背景向外填充到padding")]),v._v(" "),_("li",[v._v("content:表示背景填充内容区")])]),v._v(" "),_("h3",{attrs:{id:"溢出处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#溢出处理"}},[v._v("#")]),v._v(" 溢出处理")]),v._v(" "),_("p",[v._v("默认情况下，容器盒子（块盒）的宽度和高度会随着内容的增加而增加，如果容器盒子定宽，那么它的高度会随着内容的增加而增加，如果定宽又定高，那么当内容过多时，内容就会溢出，并且默认是溢出可见。")]),v._v(" "),_("p",[v._v("定宽高之后处理溢出")]),v._v(" "),_("ul",[_("li",[v._v("溢出隐藏：overflow:hidden")]),v._v(" "),_("li",[v._v("溢出显示：overflow:visiable")]),v._v(" "),_("li",[v._v("溢出出现滚动条：overflow：scroll")]),v._v(" "),_("li",[v._v("若溢出则自动出现滚动条：overflow:auto")])]),v._v(" "),_("h3",{attrs:{id:"短词规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#短词规则"}},[v._v("#")]),v._v(" 短词规则")]),v._v(" "),_("p",[v._v("word-break,当文字长度大于容器盒子的宽度时，该如何截断处理")]),v._v(" "),_("p",[v._v("属性值：normall (表示普通截断)，对于cjk（中国，日本，韩国）文字，在文字位置截断，对于非cjk字符，在单词（空格）位置截断，（指的是单词会保持完整）")]),v._v(" "),_("p",[v._v("break-all：表示所有字符在单词内部截断，文字依旧正常截断，单词就会被从内部截断，")]),v._v(" "),_("p",[v._v("keep-all：表示在单词（空格）位置截断，如果文字之间没有空格那么就不会被截断")]),v._v(" "),_("p",[v._v("一般默认的normall就能很好处理文字和单词")]),v._v(" "),_("h3",{attrs:{id:"空白处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#空白处理"}},[v._v("#")]),v._v(" 空白处理")]),v._v(" "),_("p",[v._v("指的是文字超出该 如何处理")]),v._v(" "),_("p",[v._v("单行处理总共三步：")]),v._v(" "),_("ol",[_("li",[v._v("white-space:nowrap;(不换行)")]),v._v(" "),_("li",[v._v("overflow:hidden;(超出部分隐藏)")]),v._v(" "),_("li",[v._v("text-overflow:ellipsis;（文本溢出用三个点表示）")])]),v._v(" "),_("p",[v._v("多行处理用js，比如vue中的过滤器")]),v._v(" "),_("p",[v._v("pre标签不会出现空白折叠是因为设置了white-space:pre;")]),v._v(" "),_("p",[v._v("使用div给他设置white-space:pre也能实现相同效果，")]),v._v(" "),_("p",[_("strong",[v._v("常规流摆放看不见浮动元素，浮动元素摆放避开常规流。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{421:function(t,a,v){"use strict";v.r(a);var _=v(42),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"作用域与闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域与闭包"}},[t._v("#")]),t._v(" 作用域与闭包")]),t._v(" "),v("h3",{attrs:{id:"js中有两种作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js中有两种作用域"}},[t._v("#")]),t._v(" js中有两种作用域")]),t._v(" "),v("p",[t._v("全局作用域")]),t._v(" "),v("ul",[v("li",[t._v("在全局作用域中声明的变量，会被提升到脚本块顶部，并成为全局对象window的属性")])]),t._v(" "),v("p",[t._v("函数作用域")]),t._v(" "),v("ul",[v("li",[t._v("在函数作用域中声明的变量，会被提升到函数的顶部。")])]),t._v(" "),v("p",[t._v("判断一个属性是否在一个对象里面可以用 in 如： a in obj")]),t._v(" "),v("p",[t._v("提倡把功能封装在函数里面，但是函数也会成为全局对象的属性，当不想函数污染全局对象，则把函数声明改为函数表达式，当函数成为一个表达式的时候，它既不会提升，也不会污染全局对象。")]),t._v(" "),v("ul",[v("li",[t._v("将函数变成一个表达式方式之一，将函数用小括号括起来，但是这样它返回的是函数本身，只能后面跟小括号立即执行，不然后面就不能通过函数名来调用了。通常将这类函数称为立即执行函数（IIFE）。由于后续不能通过函数名来调用这个函数，所以函数名也没有意义，所以可以省略不写。")])]),t._v(" "),v("p",[t._v("由于大多数情况下，函数表达式的函数名没有实际意义，因此可以省略不写。")]),t._v(" "),v("p",[t._v("没有函数名的函数称为匿名函数")]),t._v(" "),v("h3",{attrs:{id:"作用域中可以使用的变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域中可以使用的变量"}},[t._v("#")]),t._v(" 作用域中可以使用的变量")]),t._v(" "),v("p",[t._v("关键词：作用域链")]),t._v(" "),v("p",[t._v("实际用途：有时候，某个函数比较复杂，在编写过程中，可能需要另外一些函数来辅助它完成一些功能，而这些函数仅仅只能被这个函数所使用，不会再其他位置被调用，则可以将这些函数声明到这个函数的内部。")]),t._v(" "),v("h1",{attrs:{id:"闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),v("p",[t._v("是一种现象，内部函数，使用 了外部函数中的变量形成让闭包。")])])}),[],!1,null,null,null);a.default=s.exports}}]);